//! stanz - v8.1.29 https://github.com/ofajs/stanz  (c) 2018-2024 YAO
!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):(e="undefined"!=typeof globalThis?globalThis:e||self).stanz=t()}(this,(function(){"use strict";const e="https://ofajs.github.io/ofa-errors/errors",t={};globalThis.navigator&&navigator.language&&fetch(`${e}/${navigator.language.toLowerCase()}.json`).catch((()=>fetch(`${e}/default.json`))).then((e=>e.json())).catch((e=>(console.error(e),{}))).then((e=>{Object.assign(t,e)}));const r=(e,t,r)=>{const s=n(e,t);let o;return o=r?new Error(s,{cause:r}):new Error(s),o},n=(e,r)=>{if(!t[e])return`Error code: "${e}", please go to https://github.com/ofajs/ofa-errors to view the corresponding error information`;let n=t[e];if(r)for(let e in r)n=n.replace(new RegExp(`{${e}}`,"g"),r[e]);return n},s=()=>Math.random().toString(32).slice(2),o=Object.prototype.toString,a=e=>{const t=(r=e,o.call(r).toLowerCase().replace(/(\[object )|(])/g,""));var r;return"array"===t||"object"===t},i={value:null};"undefined"!=typeof document&&(document.currentScript?i.value=document.currentScript.attributes.hasOwnProperty("debug"):i.value=!0);const c="nexttick_thread_limit";let l,u=0;const h=new Set;function f(e,t=0){let o=null,a=[];return function(...f){a.push(...f),t>0?(clearTimeout(o),o=setTimeout((()=>{e.call(this,a),a=[],o=null}),t)):null===o&&(o=1,function(e){if(clearTimeout(l),l=setTimeout((()=>{u=0})),i.value)return void Promise.resolve().then((()=>{if(u++,u>1e5)throw console.log(n(c),"lastCall => ",e),r(c);e()}));const t=`t-${s()}`;h.add(t),Promise.resolve().then((()=>{if(u++,u>5e4)throw h.clear(),console.log(n(c),"lastCall => ",e),r(c);h.has(t)&&(e(),h.delete(t))}))}((()=>{o=null;const t=a.slice();a=[],e.call(this,t)})))}}const{assign:d,freeze:p}=Object;class g{constructor(e){d(this,e),p(this)}hasModified(e){if("array"===this.type)return this.path.includes(this.currentTarget.get(e));const t=e.split(".");if(this.currentTarget===this.target&&this.name===t[0])return!0;const r=y(this,t).indexOf(this.target);if(r>-1){const e=t.slice(r+1);return!e.length||this.name===e[0]}return this.path.includes(this.currentTarget[e])}hasReplaced(e){if("set"!==this.type)return!1;const t=e.split(".");if(this.target===this.currentTarget&&this.name===t[0])return!0;const r=y(this,t).indexOf(this.target);if(r>-1){return t.slice(r+1)[0]===this.name}return!1}}const y=(e,t)=>{const r=[],n=t.slice();let s=e.currentTarget;for(;n.length;){const e=n.shift();s&&(s=s[e]),r.push(s)}return r};class m extends Array{constructor(e){super(...e)}hasModified(e){return this.some((t=>t.hasModified(e)))}hasReplaced(e){return this.some((t=>t.hasReplaced(e)))}}const w=({type:e,currentTarget:t,target:r,name:n,value:s,oldValue:o,args:a,path:i=[]})=>{if(i&&i.includes(t))return void console.warn("Circular references appear");let c={type:e,target:r,name:n,oldValue:o,value:s};if("array"===e&&(delete c.value,c.args=a),t._hasWatchs){const e=new g({currentTarget:t,...c,path:[...i]});t[C].forEach((t=>{t(e)}))}t._update&&t.owner.forEach((e=>{w({currentTarget:e,...c,path:[t,...i]})}))};var b={watch(e){const t="w-"+s();return this[C].set(t,e),t},unwatch(e){return this[C].delete(e)},watchTick(e,t){return this.watch(f((t=>{(function(e){try{e.xid}catch(e){return function(e){const t=e.stack.split(/\\n/)[0].toLowerCase();return!(!t.includes("proxy")||!t.includes("revoked"))}(e)}return!1})(this)||(t=t.filter((e=>{try{e.path.forEach((e=>e.xid))}catch(e){return!1}return!0})),e(new m(t)))}),t||0))},refresh(e){const t={...e,type:"refresh",target:this,currentTarget:this};w(t)},watchUntil(e){return new Promise((t=>{let r;const n=this.watch(r=()=>{e()&&(this.unwatch(n),t(this))});r()}))}};const{defineProperties:v}=Object,_=({target:e,key:t,value:r,receiver:n,type:s,succeed:o})=>{const i=n[t];let c=r;if(I(c)){if(i===r)return!0;c._owner.push(n)}else if(a(r)){const s=Object.getOwnPropertyDescriptor(e,t);s&&!s.hasOwnProperty("value")||(c=new D(r),c._owner.push(n))}const l=i===r;!l&&I(i)&&O(i,n);const u=o(c);return!l&&!e.__unupdate&&w({type:s||"set",target:n,currentTarget:n,name:t,value:r,oldValue:i}),u},O=(e,t)=>{if(I(e)){const r=e._owner.indexOf(t);r>-1?e._owner.splice(r,1):console.error({desc:"This data is wrong, the owner has no boarding object at the time of deletion",target:t,mismatch:e})}},j={set(e,t,n,s){if("symbol"==typeof t)return Reflect.set(e,t,n,s);if(/^_/.test(t))return e.hasOwnProperty(t)?Reflect.set(e,t,n,s):v(e,{[t]:{writable:!0,configurable:!0,value:n}}),!0;try{return _({target:e,key:t,value:n,receiver:s,succeed:r=>Reflect.set(e,t,r,s)})}catch(s){const o=r("failed_to_set_data",{key:t},s);throw console.log(o.message,t,e,n),o}},deleteProperty:(e,t)=>/^_/.test(t)||"symbol"==typeof t?Reflect.deleteProperty(e,t):_({target:e,key:t,value:void 0,receiver:e[M],type:"delete",succeed:()=>Reflect.deleteProperty(e,t)})},x=["push","pop","shift","unshift","splice","reverse","sort","fill","copyWithin"],P=Symbol("placeholder");const T={},k=Array.prototype;x.forEach((e=>{k[e]&&(T[e]=function(...t){const r=Array.from(this),n=k[e].apply(this[R],t),{deletedItems:s,addedItems:o}=function(e,t){const r=Array.from(t),n=Array.from(e),s=[],o=new Map,a=e.length;for(let t=0;t<a;t++){const n=e[t],o=r.indexOf(n);o>-1?r[o]=P:s.push(n)}const i=t.length;for(let e=0;e<i;e++){const r=t[e],s=n.indexOf(r);s>-1?n[s]=P:o.set(e,r)}return{deletedItems:s,addedItems:o}}(r,this);for(let[e,t]of o)I(t)?t._owner.push(this):a(t)&&(this.__unupdate=1,this[e]=t,delete this.__unupdate);for(let e of s)O(e,this);return w({type:"array",currentTarget:this,target:this,args:t,name:e,oldValue:r}),n===this[R]?this[M]:n})})),["concat","filter","slice","flatMap","map"].forEach((e=>{if("constructor"===e||x.includes(e))return;const t=Array.prototype[e];t instanceof Function&&(T[e]=function(...e){return t.call(Array.from(this),...e)})}));const{defineProperties:S,getOwnPropertyDescriptor:E,entries:A}=Object,R=Symbol("self"),M=Symbol("proxy"),C=Symbol("watchs"),$=Symbol("isxdata"),I=e=>e&&!!e[$];function N(e,t=j){let r,{proxy:n,revoke:o}=Proxy.revocable(this,t);return n._update=1,S(this,{xid:{value:e.xid||s()},_owner:{value:[]},owner:{configurable:!0,get(){return new Set(this._owner)}},[$]:{value:!0},[R]:{configurable:!0,get:()=>this},[M]:{configurable:!0,get:()=>n},[C]:{get:()=>r||(r=new Map)},_hasWatchs:{get:()=>!!r},_revoke:{value:o}}),Object.keys(e).forEach((t=>{const r=E(e,t);let{value:s,get:o,set:a}=r;o||a?S(this,{[t]:r}):n[t]=s})),n}class D extends Array{constructor(e){return super(),N.call(this,e)}revoke(){const e=this[R];e._onrevokes&&(e._onrevokes.forEach((e=>e())),e._onrevokes.length=0),e.__unupdate=1,e[C].clear(),A(this).forEach((([e,t])=>{I(t)&&(this[e]=null)})),e._owner.forEach((e=>{A(e).forEach((([t,r])=>{r===this&&(e[t]=null)}))})),delete e[R],delete e[M],e._revoke()}toJSON(){let e={},t=!0,r=-1;Object.keys(this).forEach((n=>{let s=this[n];/\D/.test(n)?t=!1:(n=parseInt(n))>r&&(r=n),I(s)&&(s=s.toJSON()),e[n]=s})),t&&(e.length=r+1,e=Array.from(e));const n=this.xid;return S(e,{xid:{get:()=>n}}),e}toString(){return JSON.stringify(this.toJSON())}extend(e,t){return((e,t,r={})=>([...Object.getOwnPropertyNames(t),...Object.getOwnPropertySymbols(t)].forEach((n=>{const s=Object.getOwnPropertyDescriptor(t,n),{configurable:o,enumerable:a,writable:i,get:c,set:l,value:u}=s;"value"in s?e.hasOwnProperty(n)?e[n]=u:Object.defineProperty(e,n,{enumerable:a,configurable:o,writable:i,...r,value:u}):Object.defineProperty(e,n,{enumerable:a,configurable:o,...r,get:c,set:l})})),e))(this,e,t)}get(e){if(/\./.test(e)){const t=e.split(".");let n=this;for(let s=0,o=t.length;s<o;s++)try{n=n[t[s]]}catch(n){const o=r("failed_to_get_data",{key:t.slice(0,s).join(".")},n);throw console.log(o.message,":",e,this,n),o}return n}return this[e]}set(e,t){if(/\./.test(e)){const n=e.split("."),s=n.pop();let o=this;for(let t=0,s=n.length;t<s;t++)try{o=o[n[t]]}catch(s){const o=r("failed_to_get_data",{key:n.slice(0,t).join(".")},s);throw console.log(o.message,":",e,this,s),o}return o[s]=t}return this[e]=t}}D.prototype.extend({...b,...T},{enumerable:!1});const J=e=>new D(e);return Object.assign(J,{is:I}),J}));
//# sourceMappingURL=stanz.min.js.map
