//! stanz - v8.1.28 https://github.com/ofajs/stanz  (c) 2018-2024 YAO
!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):(e="undefined"!=typeof globalThis?globalThis:e||self).stanz=t()}(this,(function(){"use strict";const e=()=>Math.random().toString(32).slice(2),t=Object.prototype.toString,r=e=>{const r=(n=e,t.call(n).toLowerCase().replace(/(\[object )|(])/g,""));var n;return"array"===r||"object"===r},n={value:null};"undefined"!=typeof document&&(document.currentScript?n.value=document.currentScript.attributes.hasOwnProperty("debug"):n.value=!0);let s,o=0;const a=new Set;function i(t,r=0){let i=null,c=[];return function(...l){c.push(...l),r>0?(clearTimeout(i),i=setTimeout((()=>{t.call(this,c),c=[],i=null}),r)):null===i&&(i=1,function(t){if(clearTimeout(s),s=setTimeout((()=>{o=0})),n.value)return void Promise.resolve().then((()=>{if(o++,o>1e5){const e="nextTick exceeds thread limit";throw console.error({desc:e,lastCall:t}),new Error(e)}t()}));const r=`t-${e()}`;a.add(r),Promise.resolve().then((()=>{if(o++,o>5e4){a.clear();const e="nextTick exceeds thread limit";throw console.error({desc:e,lastCall:t}),new Error(e)}a.has(r)&&(t(),a.delete(r))}))}((()=>{i=null;const e=c.slice();c=[],t.call(this,e)})))}}const{assign:c,freeze:l}=Object;class u{constructor(e){c(this,e),l(this)}hasModified(e){if("array"===this.type)return this.path.includes(this.currentTarget.get(e));const t=e.split(".");if(this.currentTarget===this.target&&this.name===t[0])return!0;const r=h(this,t).indexOf(this.target);if(r>-1){const e=t.slice(r+1);return!e.length||this.name===e[0]}return this.path.includes(this.currentTarget[e])}hasReplaced(e){if("set"!==this.type)return!1;const t=e.split(".");if(this.target===this.currentTarget&&this.name===t[0])return!0;const r=h(this,t).indexOf(this.target);if(r>-1){return t.slice(r+1)[0]===this.name}return!1}}const h=(e,t)=>{const r=[],n=t.slice();let s=e.currentTarget;for(;n.length;){const e=n.shift();s&&(s=s[e]),r.push(s)}return r};class f extends Array{constructor(e){super(...e)}hasModified(e){return this.some((t=>t.hasModified(e)))}hasReplaced(e){return this.some((t=>t.hasReplaced(e)))}}const d=({type:e,currentTarget:t,target:r,name:n,value:s,oldValue:o,args:a,path:i=[]})=>{if(i&&i.includes(t))return void console.warn("Circular references appear");let c={type:e,target:r,name:n,oldValue:o,value:s};if("array"===e&&(delete c.value,c.args=a),t._hasWatchs){const e=new u({currentTarget:t,...c,path:[...i]});t[E].forEach((t=>{t(e)}))}t._update&&t.owner.forEach((e=>{d({currentTarget:e,...c,path:[t,...i]})}))};var p={watch(t){const r="w-"+e();return this[E].set(r,t),r},unwatch(e){return this[E].delete(e)},watchTick(e,t){return this.watch(i((t=>{(function(e){try{e.xid}catch(e){return function(e){const t=e.stack.split(/\\n/)[0].toLowerCase();return!(!t.includes("proxy")||!t.includes("revoked"))}(e)}return!1})(this)||(t=t.filter((e=>{try{e.path.forEach((e=>e.xid))}catch(e){return!1}return!0})),e(new f(t)))}),t||0))},refresh(e){const t={...e,type:"refresh",target:this,currentTarget:this};d(t)},watchUntil(e){return new Promise((t=>{let r;const n=this.watch(r=()=>{e()&&(this.unwatch(n),t(this))});r()}))}};const{defineProperties:g}=Object,y=({target:e,key:t,value:n,receiver:s,type:o,succeed:a})=>{const i=s[t];let c=n;if(A(c)){if(i===n)return!0;c._owner.push(s)}else if(r(n)){const r=Object.getOwnPropertyDescriptor(e,t);r&&!r.hasOwnProperty("value")||(c=new M(n),c._owner.push(s))}const l=i===n;!l&&A(i)&&w(i,s);const u=a(c);return!l&&!e.__unupdate&&d({type:o||"set",target:s,currentTarget:s,name:t,value:n,oldValue:i}),u},w=(e,t)=>{if(A(e)){const r=e._owner.indexOf(t);r>-1?e._owner.splice(r,1):console.error({desc:"This data is wrong, the owner has no boarding object at the time of deletion",target:t,mismatch:e})}},m={set(e,t,r,n){if("symbol"==typeof t)return Reflect.set(e,t,r,n);if(/^_/.test(t))return e.hasOwnProperty(t)?Reflect.set(e,t,r,n):g(e,{[t]:{writable:!0,configurable:!0,value:r}}),!0;try{return y({target:e,key:t,value:r,receiver:n,succeed:r=>Reflect.set(e,t,r,n)})}catch(e){const s=new Error(`failed to set ${t} \n ${e.stack}`,{cause:e});throw Object.assign(s,{key:t,value:r,target:n}),s}},deleteProperty:(e,t)=>/^_/.test(t)||"symbol"==typeof t?Reflect.deleteProperty(e,t):y({target:e,key:t,value:void 0,receiver:e[P],type:"delete",succeed:()=>Reflect.deleteProperty(e,t)})},b=["push","pop","shift","unshift","splice","reverse","sort","fill","copyWithin"],v=Symbol("placeholder");const O={},_=Array.prototype;b.forEach((e=>{_[e]&&(O[e]=function(...t){const n=Array.from(this),s=_[e].apply(this[T],t),{deletedItems:o,addedItems:a}=function(e,t){const r=Array.from(t),n=Array.from(e),s=[],o=new Map,a=e.length;for(let t=0;t<a;t++){const n=e[t],o=r.indexOf(n);o>-1?r[o]=v:s.push(n)}const i=t.length;for(let e=0;e<i;e++){const r=t[e],s=n.indexOf(r);s>-1?n[s]=v:o.set(e,r)}return{deletedItems:s,addedItems:o}}(n,this);for(let[e,t]of a)A(t)?t._owner.push(this):r(t)&&(this.__unupdate=1,this[e]=t,delete this.__unupdate);for(let e of o)w(e,this);return d({type:"array",currentTarget:this,target:this,args:t,name:e,oldValue:n}),s===this[T]?this[P]:s})})),["concat","filter","slice","flatMap","map"].forEach((e=>{if("constructor"===e||b.includes(e))return;const t=Array.prototype[e];t instanceof Function&&(O[e]=function(...e){return t.call(Array.from(this),...e)})}));const{defineProperties:x,getOwnPropertyDescriptor:j,entries:k}=Object,T=Symbol("self"),P=Symbol("proxy"),E=Symbol("watchs"),S=Symbol("isxdata"),A=e=>e&&!!e[S];function R(t,r=m){let n,{proxy:s,revoke:o}=Proxy.revocable(this,r);return s._update=1,x(this,{xid:{value:t.xid||e()},_owner:{value:[]},owner:{configurable:!0,get(){return new Set(this._owner)}},[S]:{value:!0},[T]:{configurable:!0,get:()=>this},[P]:{configurable:!0,get:()=>s},[E]:{get:()=>n||(n=new Map)},_hasWatchs:{get:()=>!!n},_revoke:{value:o}}),Object.keys(t).forEach((e=>{const r=j(t,e);let{value:n,get:o,set:a}=r;o||a?x(this,{[e]:r}):s[e]=n})),s}class M extends Array{constructor(e){return super(),R.call(this,e)}revoke(){const e=this[T];e._onrevokes&&(e._onrevokes.forEach((e=>e())),e._onrevokes.length=0),e.__unupdate=1,e[E].clear(),k(this).forEach((([e,t])=>{A(t)&&(this[e]=null)})),e._owner.forEach((e=>{k(e).forEach((([t,r])=>{r===this&&(e[t]=null)}))})),delete e[T],delete e[P],e._revoke()}toJSON(){let e={},t=!0,r=-1;Object.keys(this).forEach((n=>{let s=this[n];/\D/.test(n)?t=!1:(n=parseInt(n))>r&&(r=n),A(s)&&(s=s.toJSON()),e[n]=s})),t&&(e.length=r+1,e=Array.from(e));const n=this.xid;return x(e,{xid:{get:()=>n}}),e}toString(){return JSON.stringify(this.toJSON())}extend(e,t){return((e,t,r={})=>([...Object.getOwnPropertyNames(t),...Object.getOwnPropertySymbols(t)].forEach((n=>{const s=Object.getOwnPropertyDescriptor(t,n),{configurable:o,enumerable:a,writable:i,get:c,set:l,value:u}=s;"value"in s?e.hasOwnProperty(n)?e[n]=u:Object.defineProperty(e,n,{enumerable:a,configurable:o,writable:i,...r,value:u}):Object.defineProperty(e,n,{enumerable:a,configurable:o,...r,get:c,set:l})})),e))(this,e,t)}get(e){if(/\./.test(e)){const t=e.split(".");let r=this;for(let e=0,n=t.length;e<n;e++)try{r=r[t[e]]}catch(n){const s=new Error(`Failed to get data : ${t.slice(0,e).join(".")} \n${n.stack}`,{cause:n});throw Object.assign(s,{target:r}),s}return r}return this[e]}set(e,t){if(/\./.test(e)){const r=e.split("."),n=r.pop();let s=this;for(let e=0,t=r.length;e<t;e++)try{s=s[r[e]]}catch(t){const n=new Error(`Failed to get data : ${r.slice(0,e).join(".")} \n${t.stack}`,{cause:t});throw Object.assign(n,{target:s}),n}return s[n]=t}return this[e]=t}}M.prototype.extend({...p,...O},{enumerable:!1});const $=e=>new M(e);return Object.assign($,{is:A}),$}));
//# sourceMappingURL=stanz.min.js.map
