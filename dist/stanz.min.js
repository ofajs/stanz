/*!
* stanz v7.0.0
* https://github.com/kirakiray/stanz
* 
* (c) 2018-2021 YAO
* Released under the MIT License.
*/((t,e)=>{"use strict";"object"==typeof exports?module.exports=e():"function"==typeof define&&define.amd?define(e):t.stanz=e()})(this,()=>{"use strict";const t=()=>Math.random().toString(32).substr(2);var e=Object.prototype.toString,r=t=>e.call(t).toLowerCase().replace(/(\[object )|(])/g,"");const s=t=>r(t).search("function")>-1;const o=Object.defineProperties,i=Object.getOwnPropertyDescriptor,n=t=>t instanceof b,c=null!==document.currentScript.getAttribute("debug"),a=(()=>{if(c){let e=new Map;return(r,s)=>{s||(s=t());let o=e.get(s);clearTimeout(o),e.set(s,setTimeout(()=>{r(),e.delete(s)}))}}let e=new Map,r=t=>Promise.resolve().then(()=>t());"object"==typeof process&&process.nextTick&&(r=process.nextTick);let s=!1;return(o,i)=>{i||(i=t()),e.set(i,{key:i,fun:o}),s||(s=!0,r(()=>{e.size&&e.forEach(({key:t,fun:r})=>{try{r()}catch(t){console.error(t)}e.delete(t)}),e.clear(),s=!1}))}})(),l=(t,e)=>{let r,s=[];const o=i=>{s.push(Object.assign({},i)),e?(clearTimeout(r),r=setTimeout(()=>{t(s),s.length=0},e)):a(()=>{t(s),s.length=0},o)};return o},h=(t,e,r={})=>{Object.keys(e).forEach(s=>{let{get:o,set:n,value:c}=i(e,s);c?t.hasOwnProperty(s)?t[s]=c:Object.defineProperty(t,s,{...r,value:c}):Object.defineProperty(t,s,{...r,get:o,set:n})})},u=(Date.now(),Symbol("self")),p=Symbol("proxy"),f=Symbol("watchs"),y=Symbol("can_update"),d=new Set(["root","sub","revoke"]),w=(t,e,r,s)=>{let o;o=e.path=r?[t[p],...r]:[t[p]],t[f].forEach(t=>t(e)),s||t._unupdate||t.owner&&t.owner.forEach(t=>w(t,e,o.slice()))};class b{constructor(e,r){let s;e.get?(s=new Proxy(this,{get:e.get,ownKeys:e.ownKeys,getOwnPropertyDescriptor:e.getOwnPropertyDescriptor,set:g.set}),delete e.get,delete e.ownKeys,delete e.getOwnPropertyDescriptor):s=new Proxy(this,g);let n=r;o(this,{[u]:{value:this},[p]:{value:s},xid:{value:"x_"+t()},_xtatus:{get:()=>n,set(t){if(!d.has(t))throw{target:s,desc:`xtatus not allowed to be set ${t}`};const e=this.owner.size;if("revoke"===t&&e)throw{target:s,desc:"the owner is not empty"};if("revoke"===n&&"revoke"!==t)e||O(this);else if("sub"===n&&"root"===t)throw{target:s,desc:"cannot modify sub to root"};n=t}},owner:{configurable:!0,writable:!0,value:new Set},length:{configurable:!0,writable:!0,value:0},[f]:{value:new Map},[y]:{writable:!0,value:0}});let c=-1;return Object.keys(e).forEach(t=>{let r=i(e,t),{value:n,get:a,set:l}=r;"get"!==t&&(/\D/.test(t)||(t=parseInt(t))>c&&(c=t),a||l?o(this,{[t]:r}):s[t]=n)}),c>-1&&(this.length=c+1),this[y]=1,s}watch(e){const r="e_"+t();return this[f].set(r,e),r}unwatch(t){return this[f].delete(t)}setData(t,e){let s,o=r(e);"array"!=o&&"object"!=o||(e=m(e,"sub")).owner.add(this);const i=Object.getOwnPropertyDescriptor(this,t),n=this[p];try{s=n[t]}catch(t){}if(s===e)return!0;let c;return i&&i.set?(i.set.call(n,e),c=!0):c=Reflect.set(this,t,e),this[y]&&w(this,{xid:this.xid,name:"setData",args:[t,e]}),x(s,this),c}update(t={}){w(this,Object.assign({},t,{xid:this.xid,isCustom:!0}))}delete(t){if(/^_/.test(t)||"symbol"==typeof t)return Reflect.deleteProperty(this,t);if(!t)return!1;const e=this[u];let r=e[t];x(r,e);let s=Reflect.deleteProperty(e,t);return w(this,{xid:this.xid,name:"delete",args:[t]}),s}}const g={set(t,e,r,s){if("symbol"==typeof e)return Reflect.set(t,e,r,s);if(/^_/.test(e))return t.hasOwnProperty(e)?Reflect.set(t,e,r,s):o(t,{[e]:{writable:!0,configurable:!0,value:r}}),!0;try{return t.setData(e,r)}catch(t){throw{desc:`failed to set ${e}`,key:e,value:r,target:s}}},deleteProperty:function(t,e){return t.delete(e)}},x=(t,e)=>{if(!n(t))return;const{owner:r}=t;r.delete(e),r.size||(t._xtatus="revoke",Object.values(t).forEach(e=>{x(e,t[u])}))},O=t=>{"revoke"===t._xtatus&&Object.values(t).forEach(e=>{n(e)&&(O(e),e.owner.add(t),e._xtatus="sub")})},m=(t,e="root")=>n(t)?(t._xtatus=e,t):new b(t,e);h(b.prototype,{seek(t){let e=[];if(!s(t)){let e=new Function(`with(this){return ${t}}`);t=(t=>{try{return e.call(t,t)}catch(t){}})}return t.call(this,this)&&e.push(this),Object.values(this).forEach(r=>{n(r)&&e.push(...r.seek(t))}),e},watchTick(t,e){return this.watch(l(t,e))},watchUntil(t){let e=s(t);if(!e&&/[^=><]=[^=]/.test(t))throw"cannot use single =";return new Promise(r=>{let s,o=e?t.bind(this):new Function(`\n        try{with(this){\n            return ${t}\n        }}catch(e){}`).bind(this);const i=this.watchTick(s=(()=>{let t=o();t&&(this.unwatch(i),r(t))}));s()})},watchKey(t,e){e&&Object.keys(t).forEach(e=>t[e].call(this,this[e]));let r={};return Object.keys(t).forEach(t=>{r[t]=this[t]}),this.watch(l(e=>{Object.keys(t).forEach(s=>{let o=this[s];if(r[s]!==o)t[s].call(this,o);else if(n(o)){e.some(t=>{return t.path[1]==o})&&t[s].call(this,o)}r[s]=o})}))},toJSON(){let t={},e=!0,r=0;Object.keys(this).forEach(s=>{let o=this[s];/\D/.test(s)?e=!1:(s=parseInt(s))>r&&(r=s),n(o)&&(o=o.toJSON()),t[s]=o}),e&&(t.length=r+1,t=Array.from(t));const s=this.xid;return o(t,{xid:{get:()=>s}}),t},toString(){return JSON.stringify(this.toJSON())}}),["concat","every","filter","find","findIndex","forEach","map","slice","some","indexOf","lastIndexOf","includes","join"].forEach(t=>{let e=Array.prototype[t];e&&o(b.prototype,{[t]:{value:e}})});const v=Array.prototype.splice;h(b.prototype,{splice(t,e,...s){let o=this[u];s=s.map(t=>{let e=r(t);return"array"!=e&&"object"!=e||(t=m(t,"sub")).owner.add(o),t});let i="number"==r(e)?e:this.length-t,n=v.call(o,t,i,...s);return n.forEach(t=>x(t,o)),w(this,{xid:this.xid,name:"splice",args:[t,e,...s]}),n},unshift(...t){return this.splice(0,0,...t),this.length},push(...t){return this.splice(this.length,0,...t),this.length},shift(){return this.splice(0,1)[0]},pop(){return this.splice(this.length-1,1)[0]}}),["sort","reverse"].forEach(t=>{const e=Array.prototype[t];e&&o(b.prototype,{[t]:{value(...r){let s=e.apply(this[u],r);return w(this,{xid:this.xid,name:t}),s}}})});const j=t=>m(t,"root");return Object.assign(j,{version:"7.0.0",v:7e6,isxdata:n}),j});